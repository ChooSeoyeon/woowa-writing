# 테이블보다 도메인을 먼저 설계해보기

오늘날의 개발에서 객체지향 프로그래밍과 관계형 데이터베이스는 자주 함께 사용되지만, 이 둘은 서로 다른 개념적 접근 방식을 가지고 있습니다. 객체지향은 상태와 행위를 중심으로 설계되며, 객체 사이의 관계와 협력에 초점을 맞추고 있습니다. 반면, 관계형 데이터베이스는 데이터를 표 형식으로 저장하고, 그 데이터를 효율적으로 조회하는 데 집중합니다.

이 글에서는 객체지향 설계에서 말하는 도메인 모델과 JPA 엔티티를 비교하고, 이 둘을 구분하여 사용하는 방법을 알아보겠습니다. 또한, 두 개념을 동일시할 때 발생하는 문제점과 이를 해결하기 위한 도메인과 엔티티 분리 전략을 설명하겠습니다.

## 객체지향 도메인: 행위를 중심으로 한 설계

객체지향 설계에서 도메인은 단순히 데이터의 집합이 아닌, 비즈니스 로직을 담고 있는 핵심 모델입니다. 이 도메인은 행위(메서드)를 통해 상태(필드)를 변화시키며, 이를 통해 비즈니스 요구 사항을 해결합니다.

### 객체지향 도메인의 특징

1. 불변성
객체지향 설계에서 중요한 원칙 중 하나는 불변성입니다. 도메인은 상태 변경보다는 새로운 객체를 생성하는 방식을 채택하여 기존 객체의 무결성을 유지합니다. 예를 들어, 두 금액을 더하는 연산을 수행할 때, 기존 금액 객체를 수정하는 대신 새로운 금액 객체를 반환하는 방식입니다.

2. 상태보다 행위 중심
도메인 모델은 상태보다는 행위에 중점을 둡니다. 즉, 객체가 어떠한 데이터를 가지고 있느냐보다는 그 객체가 어떤 역할을 수행하는지가 중요합니다. 이는 "객체가 스스로의 책임을 가진다"는 객체지향 설계의 철학을 반영합니다.

3. 응집도와 책임
도메인은 단일 책임 원칙(SRP)을 따릅니다. 즉, 하나의 도메인은 하나의 역할만을 수행하고, 다른 도메인과 결합되지 않도록 설계합니다. 이를 통해 객체 간의 결합도를 낮추고, 시스템의 유지보수성과 확장성을 높일 수 있습니다.

```
public class Money {
    private final BigDecimal amount;

    public Money(BigDecimal amount) {
        this.amount = amount;
    }

    public Money add(Money other) {
        return new Money(this.amount.add(other.amount));
    }

    public BigDecimal getAmount() {
        return this.amount;
    }
}
```

위 예시에서 Money 객체는 불변 객체입니다. 금액을 더하는 add 메서드는 새로운 Money 객체를 반환하고, 기존 객체의 상태를 변경하지 않습니다. 이는 도메인의 기본 원칙인 불변성을 잘 보여줍니다.

## JPA 엔티티: 데이터 저장을 위한 모델

JPA(Java Persistence API)는 객체를 관계형 데이터베이스에 저장하기 위한 표준 API입니다. JPA 엔티티는 데이터베이스와의 연동을 담당하며, 객체의 생명주기를 영속성 컨텍스트(Persistence Context)에 의해 관리합니다.

### JPA 엔티티의 특징

1. 상태 관리
JPA 엔티티는 데이터베이스 테이블의 행(row)에 해당하는 객체로, 데이터의 상태를 변경하고 그 변경된 상태를 데이터베이스에 반영합니다. 객체는 영속성 컨텍스트 내에서 관리되며, 트랜잭션이 끝날 때 데이터베이스에 저장됩니다.

2. 영속성 컨텍스트
JPA 엔티티는 영속성 컨텍스트라는 일종의 캐시 메커니즘에 의해 관리됩니다. 엔티티 객체는 영속성 컨텍스트에 의해 추적되며, 변경된 필드나 값은 자동으로 데이터베이스에 반영됩니다.

3. 데이터베이스 중심 설계
JPA 엔티티는 객체와 데이터베이스 사이의 매핑을 위해 설계되었습니다. 데이터베이스 스키마와 객체의 필드가 1:1로 대응되며, 객체지향 원칙보다 데이터 저장 및 조회에 더 중점을 둡니다.

```
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    
    private String name;

    public User() {}

    public User(String name) {
        this.name = name;
    }

    public void changeName(String newName) {
        this.name = newName;
    }

    public String getName() {
        return name;
    }
}
```
위 User 엔티티는 데이터베이스 테이블의 한 행을 표현합니다. JPA 엔티티는 데이터베이스와의 연동을 위해 필드마다 어노테이션(@Id, @GeneratedValue 등)을 사용하며, 데이터베이스 중심으로 설계되었습니다.

## 객체지향과 JPA의 트레이드오프

객체지향 설계와 JPA 엔티티 사이에는 몇 가지 중요한 트레이드오프가 존재합니다. 두 개념은 각각의 목적과 장점을 가지고 있지만, 이를 동일하게 사용하는 경우 다음과 같은 문제가 발생할 수 있습니다.

1. 객체지향 원칙의 훼손
JPA 엔티티는 상태 변경을 전제로 하고 있으며, 불변성을 유지하지 않습니다. 반면, 객체지향 설계에서는 불변성을 유지하고, 상태를 변경하지 않는 것이 중요합니다. JPA 엔티티를 그대로 도메인 모델로 사용할 경우, 객체지향 설계의 원칙인 불변성과 단일 책임 원칙이 훼손될 수 있습니다.

2. 영속성 컨텍스트와 비즈니스 로직의 결합
JPA 엔티티는 영속성 컨텍스트에 의존합니다. 이는 데이터베이스와의 강한 결합을 의미하며, 비즈니스 로직이 데이터베이스의 상태에 종속되게 만듭니다. 도메인 모델이 데이터베이스와 결합되면 비즈니스 로직을 재사용하거나 테스트하는 데 어려움이 생깁니다.

3. 성능 최적화와 객체지향 설계의 상충
JPA 엔티티는 데이터 저장과 조회에 최적화되어 있으나, 객체지향 설계에서는 비즈니스 로직이 우선시됩니다. 두 가지 목적이 상충할 때, 성능을 우선시하면 객체지향 설계 원칙을 희생해야 하고, 반대로 객체지향 원칙을 지키면 성능 최적화를 포기해야 하는 딜레마에 빠질 수 있습니다.

## JPA 엔티티와 도메인 엔티티를 동일시할 때의 문제
많은 개발자들이 JPA 엔티티와 도메인 모델을 동일시하여 사용하는 경우가 많습니다. 하지만 이 둘을 동일하게 취급할 때 다음과 같은 문제들이 발생합니다.

1. 불변성 문제
JPA 엔티티는 기본적으로 가변적이며, 데이터베이스의 상태에 따라 객체의 상태가 변경됩니다. 하지만 도메인은 비즈니스 로직을 책임지기 때문에 불변성을 유지하는 것이 바람직합니다. 이 차이점으로 인해, 도메인 로직이 엔티티와 결합되면 불변성을 보장하기 어렵습니다.

2. 비즈니스 로직과 데이터베이스 로직의 혼합
JPA 엔티티는 데이터 저장과 연관된 로직을 포함하고 있기 때문에, 도메인 로직과 데이터 로직이 섞여버리는 문제가 발생합니다. 이는 코드의 가독성을 떨어뜨리고, 유지보수를 어렵게 만듭니다.

3. 테스트의 어려움
JPA 엔티티는 데이터베이스와 밀접하게 결합되어 있어, 데이터베이스 없이 독립적으로 테스트하기 어렵습니다. 반면 도메인 모델은 비즈니스 로직을 독립적으로 테스트할 수 있어야 하므로, 두 개념이 분리되지 않으면 테스트 환경을 설정하는 데 많은 비용이 듭니다.

## 관계형 데이터베이스와 객체 간의 패러다임 불일치

관계형 데이터베이스와 객체 사이의 패러다임 불일치는 오랫동안 해결되지 않은 문제로 남아 있습니다. 객체지향의 개념은 객체 간의 협력과 행위를 중시하지만, 관계형 데이터베이스는 데이터를 정규화하고, 각 데이터를 독립적으로 저장하는 데 중점을 둡니다.

이 패러다임 불일치는 객체-관계 매핑(Object-Relational Mapping, ORM) 도구인 JPA를 통해 어느 정도 해소되고 있지만, 여전히 완벽한 해결책은 아닙니다. 특히 복잡한 도메인 로직을 처리하는 데 있어 JPA 엔티티만으로는 한계가 있으며, 이는 객체와 데이터베이스 간의 개념적 차이에서 기인합니다.

## 엔티티에서 도메인 분리하기: 총대마켓 프로젝트의 사례

저희 팀이 진행했던 총대마켓 프로젝트에서 JPA 엔티티와 도메인을 분리한 경험을 소개하고자 합니다. 총대마켓은 공동 구매 서비스를 제공하는 웹 애플리케이션으로, 초기에는 JPA 엔티티를 그대로 도메인 모델로 사용했습니다. 하지만 프로젝트가 커지면서 JPA 엔티티와 도메인 로직을 분리해야 할 필요성을 느꼈고, 이를 통해 얻게 된 교훈들을 공유합니다.

1. 초기 설계: JPA 엔티티와 도메인의 결합
프로젝트 초기에는 JPA 엔티티를 그대로 도메인으로 사용했습니다. 이로 인해 도메인 로직과 데이터베이스 연동 로직이 혼합되었고, 유지보수와 테스트에 어려움을 겪게 되었습니다.

2. 엔티티와 도메인 분리 후의 개선 사항
도메인 로직을 JPA 엔티티에서 분리하여, 도메인은 비즈니스 로직을 담당하고 JPA 엔티티는 데이터 저장을 책임지도록 설계했습니다. 이로 인해 비즈니스 로직을 독립적으로 테스트할 수 있었고, 코드의 응집도와 가독성이 크게 개선되었습니다.

```
// Domain
public class Offering {
    private final long id;
    private final Member member;
    private final String title;

    public Offering(long id, Member member, String title) {
        this.id = id;
        this.member = member;
        this.title = title;
    }

    public void changeTitle(String newTitle) {
        // 도메인 로직
    }
}

// JPA 엔티티
@Entity
public class JpaOffering {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @ManyToOne
    private JpaMember member;

    public JpaOffering() {}

    public JpaOffering(Offering offering) {
        this.title = offering.getTitle();
        // 기타 매핑 로직
    }

    public Offering toOffering() {
        return new Offering(id, member.toMember(), title);
    }
}
```

## 결론
객체지향 설계의 도메인과 JPA 엔티티는 각기 다른 목적을 가지고 있으며, 이 둘을 동일하게 취급할 경우 여러 문제점이 발생합니다. 도메인은 비즈니스 로직을 담고, JPA 엔티티는 데이터베이스와의 연동을 책임지며, 이 둘을 분리하여 관리함으로써 시스템의 유지보수성, 확장성, 테스트 가능성을 높일 수 있습니다.

클린 아키텍처의 원칙에 따라 도메인 로직은 외부 시스템에 의존하지 않고 독립적으로 설계되어야 하며, 이를 위해 도메인과 JPA 엔티티를 명확히 구분하는 것이 중요합니다. 앞으로의 프로젝트에서 도메인과 엔티티의 역할을 명확히 하고, 이를 분리하여 관리함으로써 더욱 견고한 시스템을 설계해 나가길 바랍니다.

